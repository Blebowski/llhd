/* Copyright (c) 2014 Fabian Schuiki */
#include "llhd/unicode.hpp"
#include "llhd/allocator/PoolAllocator.hpp"
#include <fstream>
#include <iostream>
#include <sstream>

/// \file Reads the `CaseFolding.txt` file which is part of the Unicode
/// Character database, and digests its information into an efficient mapping
/// structure which is written to disk.

struct MappingGenerator;
struct MappingFragment;

struct MappingFragment {
	MappingFragment* frags[16];
	std::string value;

	MappingFragment& operator() (unsigned bits);
	MappingFragment& operator= (const std::string& v);

	MappingGenerator& gen;
	MappingFragment(MappingGenerator& gen);
};

struct MappingGenerator {
	llhd::PoolAllocator<> alloc;
	MappingFragment root;

	MappingGenerator(): root(*this) {}

	MappingFragment& operator() (unsigned bits) {
		return root(bits);
	}
};

MappingFragment& MappingFragment::operator() (unsigned bits) {
	assert(bits < 16);
	auto& frag = frags[bits];
	if (!frag)
		// frag = new MappingFragment(gen);
		frag = gen.alloc.one<MappingFragment>(gen); // causes a crash
	return *frag;
}

MappingFragment& MappingFragment::operator= (const std::string& v) {
	value = v;
	return *this;
}

MappingFragment::MappingFragment(MappingGenerator& gen): gen(gen) {
	for (int i = 0; i < 16; i++)
		frags[i] = NULL;
}


int main(int argc, char** argv)
{
	// Verify we have enough arguments.
	if (argc != 3) {
		std::cerr << "usage: " << argv[0] << " <input> <output>\n";
		return 1;
	}

	// Open the file for reading.
	std::ifstream fin(argv[1]);
	if (!fin.good()) {
		std::cerr << "unable to open input file for writing\n";
		return 2;
	}

	// Parse the input file and generate the different table versions.
	MappingGenerator utf32Mapping;
	MappingGenerator utf16Mapping;
	MappingGenerator utf8Mapping;

	while (fin.good()) {

		// Skip empty lines.
		if (fin.peek() == '\n') {
			fin.get();
			continue;
		}

		// Skip comment lines.
		if (fin.peek() == '#') {
			while (fin.get() != '\n' && fin.good());
			continue;
		}

		// Abort in case the peeking caused the stream to reach its end.
		if (!fin.good())
			break;

		unsigned code;
		char status;
		unsigned mapping[16] = {0};

		fin >> std::hex >> code;
		while (fin.peek() == ';' || fin.peek() == ' ')
			fin.get();
		fin >> status;
		while (fin.peek() == ';' || fin.peek() == ' ')
			fin.get();

		unsigned i;
		for (i = 0; i < 15;) {
			fin >> std::hex >> mapping[i++];
			if (fin.peek() == ';')
				break;
			while (fin.peek() == ' ')
				fin.get();
		}
		mapping[i] = 0;
		while (fin.get() != '\n' && fin.good());

		std::cout << "read code point " << std::hex << code << ", status " << status << ", mapping " << mapping[0] << ':' << mapping[1] << ':' << mapping[2] << '\n';

		std::stringstream utf32v;
		utf32v << "{ " << std::hex;
		for (i = 0; i < 16 && mapping[i] != 0; i++) {
			if (i != 0)
				utf32v << ", ";
			utf32v << "0x" << mapping[i];
		}
		utf32v << ", 0 }";
		std::cout << "  = " << utf32v.str() << '\n';

		utf32Mapping
			((code >> 28) & 0xf)
			((code >> 24) & 0xf)
			((code >> 20) & 0xf)
			((code >> 16) & 0xf)
			((code >> 12) & 0xf)
			((code >>  8) & 0xf)
			((code >>  4) & 0xf)
			((code >>  0) & 0xf) = utf32v.str();
	}

	// Open the file for writing.
	std::ofstream fout(argv[2]);
	if (!fout.good()) {
		std::cerr << "unable to open output file for writing\n";
		return 3;
	}
	fout << "/* This file was automatically generated by unicode-gen-casefolding. DO NOT MODIFY. */\n";

	return 0;
}
