/* Copyright (c) 2014 Fabian Schuiki */
#include "llhd/Assembly.hpp"
#include "llhd/sim/Simulation.hpp"
#include "llhd/sim/SimulationExpr.hpp"
#include <cassert>
#include <iostream>
#include <stdexcept>
using namespace llhd;

Simulation::Simulation(const AssemblyModule& as):
	as(as) {

	// Initialize the signal wrappers.
	for (auto& is : as.signals) {
		wrap(is.second.get());
	}
}

/// Wraps the given signal in a structure suitable for simulation. Called
/// internally when the module to be simulated is prepared.
void Simulation::wrap(const AssemblySignal *signal) {

	// Wrap the signal in a simulation-specific structure.
	std::unique_ptr<SimulationSignal> w(new SimulationSignal(
		signal,
		wrap(signal->type.get())));

	// If the signal has an associated assignment, wrap that accordingly.
	if (signal->assignment) {
		wrap(w.get(), signal->assignment.get());
	}

	// Add the signal to the list of wrappers.
	wrappers[signal] = std::move(w);
}

/// Wraps the given type in a structure suitable for simulation.
SimulationValue Simulation::wrap(const AssemblyType *type) {
	if (dynamic_cast<const AssemblyTypeLogic*>(type)) {
		return SimulationValue(1, kLogicU);
	}
	if (auto subtype = dynamic_cast<const AssemblyTypeWord*>(type)) {
		if (dynamic_cast<const AssemblyTypeLogic*>(subtype->type.get())) {
			return SimulationValue(subtype->width, kLogicU);
		}
	}
	throw std::runtime_error("unknown type");
}

/// Wraps the given expression in a structure that implements the corresponding
/// operation and keeps track of the input and output signals.
void Simulation::wrap(
	SimulationSignal *signal,
	const AssemblyExpr *expr) {

	SimulationDependency *w = nullptr;

	// identity
	if (auto a = dynamic_cast<const AssemblyExprIdentity*>(expr)) {
		auto arg0 = wrappers[a->op].get();
		assert(arg0);
		auto it = dependencies.emplace(new SimulationIdentityExpr(
			signal, arg0));
		w = it.first->get();
		arg0->addDependency(w);
	}

	// delayed
	else if (auto a = dynamic_cast<const AssemblyExprDelayed*>(expr)) {
		auto arg0 = wrappers[a->op].get();
		assert(arg0);
		auto it = dependencies.emplace(new SimulationDelayExpr(
			signal, arg0, a->d));
		w = it.first->get();
		arg0->addDependency(w);
	}

	// boolean
	else if (auto a = dynamic_cast<const AssemblyExprBoolean*>(expr)) {
		auto arg0 = wrappers[a->op0].get();
		auto arg1 = wrappers[a->op1].get();
		assert(arg0 && arg1);

		SimulationBooleanExpr::FuncType fn;
		switch (a->type) {
			case AssemblyExprBoolean::kAND:
				fn = SimulationBooleanExpr::fAND; break;
			case AssemblyExprBoolean::kNAND:
				fn = SimulationBooleanExpr::fNAND; break;
			case AssemblyExprBoolean::kOR:
				fn = SimulationBooleanExpr::fOR; break;
			case AssemblyExprBoolean::kNOR:
				fn = SimulationBooleanExpr::fNOR; break;
			case AssemblyExprBoolean::kXOR:
				fn = SimulationBooleanExpr::fXOR; break;
		}

		auto it = dependencies.emplace(new SimulationBooleanExpr(
			signal, arg0, arg1, fn));
		w = it.first->get();
		arg0->addDependency(w);
		arg1->addDependency(w);
	}

	// unknown
	else {
		throw std::runtime_error("unknown expression");
	}
}

/// Calls the function \a fn for all signals that are being simulated, passing
/// it each signal and that signal's current value. Useful to get a dump of the
/// current simulation state.
void Simulation::eachSignal(ObserverFunc fn) {
	for (auto& is : wrappers) {
		fn(T, is.second->getAssemblySignal(), is.second->getValue());
	}
}

/// Adds an event to the event queue. Useful for debugging and applying external
/// stimuli generated by the user.
void Simulation::addEvent(
	SimulationTime T,
	const AssemblySignal* signal,
	const SimulationValue& value) {

	auto it = wrappers.find(signal);
	if (it == wrappers.end())
		return;

	eventQueue.addEvent(T, it->second.get(), value);
}

/// Advances the simulation one step and calls \a fn for all signals that have
/// changed their value.
void Simulation::step(ObserverFunc fn) {

	// Do nothing if the event queue is empty.
	if (eventQueue.isAtEnd())
		return;

	// Fetch the next time step from the queue and iterate over all events that
	// are listed for that specific point in time.
	T = eventQueue.nextTime();
	std::vector<SimulationDependency*> outdated;
	outdated.reserve(64);
	eventQueue.nextEvents([&](const SimulationEvent& ev){
		auto& sig = *ev.signal;
		if (sig.getValue() == ev.value)
			return;
		sig.setValue(ev.value);
		fn(T, sig.getAssemblySignal(), ev.value);

		// Mark all dependencies of this signal as outdated.
		sig.eachDependency([&](SimulationDependency *dep){
			if (dep->markOutdated())
				outdated.push_back(dep);
		});
	});
	eventQueue.pop();

	// Update all dependencies that were marked outdated.
	for (auto dep : outdated) {
		dep->update(T, eventQueue);
		dep->clearOutdated();
	}
}
