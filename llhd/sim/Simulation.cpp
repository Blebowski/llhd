/* Copyright (c) 2014 Fabian Schuiki */
#include "llhd/Assembly.hpp"
#include "llhd/sim/Simulation.hpp"
#include "llhd/sim/SimulationExpr.hpp"
#include <cassert>
#include <iostream>
#include <stdexcept>
using namespace llhd;

Simulation::Simulation(const AssemblyModule& as):
	as(as) {

	// Initialize the signal wrappers.
	for (auto& is : as.signals) {
		wrap(is.second.get());
	}

	// Initialize the signal assignments.
	for (auto& wr : wrappers) {
		auto sig = wr.second.get();
		if (sig->getAssemblySignal()->assignment) {
			wrap(sig, sig->getAssemblySignal()->assignment.get());
		}
	}
}

/// Wraps the given signal in a structure suitable for simulation. Called
/// internally when the module to be simulated is prepared.
void Simulation::wrap(const AssemblySignal *signal) {

	// Wrap the signal in a simulation-specific structure.
	std::unique_ptr<SimulationSignal> w(new SimulationSignal(
		signal,
		wrap(signal->type.get())));

	// If the signal has an associated assignment, wrap that accordingly.
	// if (signal->assignment) {
	// 	wrap(w.get(), signal->assignment.get());
	// }

	// Add the signal to the list of wrappers.
	wrappers[signal] = std::move(w);
}

/// Wraps the given type in a structure suitable for simulation.
SimulationValue Simulation::wrap(const AssemblyType *type) {
	if (dynamic_cast<const AssemblyTypeLogic*>(type)) {
		return SimulationValue(1, kLogicU);
	}
	if (auto subtype = dynamic_cast<const AssemblyTypeWord*>(type)) {
		if (dynamic_cast<const AssemblyTypeLogic*>(subtype->type.get())) {
			return SimulationValue(subtype->width, kLogicU);
		}
	}
	throw std::runtime_error("unknown type");
}

/// Wraps the given expression in a structure that implements the corresponding
/// operation and keeps track of the input and output signals.
void Simulation::wrap(
	SimulationSignal *signal,
	const AssemblyIns *expr) {

	SimulationDependency *w = nullptr;

	switch (expr->getOpcode() & AssemblyIns::kOpMask) {

		// unary operations
		case AssemblyIns::kUnaryOps: {
			auto uins = (const AssemblyUnaryIns*)expr;
			auto arg0 = wrappers[uins->getArg()].get();
			assert(arg0);

			switch (expr->getOpcode()) {
				case AssemblyIns::kMove: {
					if (uins->getDelay() == 0) {
						auto it = dependencies.emplace(
							new SimulationIdentityExpr(signal, arg0));
						w = it.first->get();
						arg0->addDependency(w);
					} else {
						auto it = dependencies.emplace(new SimulationDelayExpr(
							signal, arg0, uins->getDelay()));
						w = it.first->get();
						arg0->addDependency(w);
					}
				} break;
				default:
					throw std::runtime_error("unknown unary opcode");
			}
		} break;

		// binary operations
		case AssemblyIns::kBinaryOps: {
			auto bins = (const AssemblyBinaryIns*)expr;
			auto arg0 = wrappers[bins->getArg0()].get();
			auto arg1 = wrappers[bins->getArg1()].get();
			assert(arg0 && arg1);

			SimulationBooleanExpr::FuncType fn;
			switch (bins->getOpcode()) {
				case AssemblyIns::kBoolAND:
					fn = SimulationBooleanExpr::fAND; break;
				case AssemblyIns::kBoolNAND:
					fn = SimulationBooleanExpr::fNAND; break;
				case AssemblyIns::kBoolOR:
					fn = SimulationBooleanExpr::fOR; break;
				case AssemblyIns::kBoolNOR:
					fn = SimulationBooleanExpr::fNOR; break;
				case AssemblyIns::kBoolXOR:
					fn = SimulationBooleanExpr::fXOR; break;
				default:
					throw std::runtime_error("unknown boolean opcode");
			}

			auto it = dependencies.emplace(new SimulationBooleanExpr(
				signal, arg0, arg1, fn));
			w = it.first->get();
			arg0->addDependency(w);
			arg1->addDependency(w);
		} break;

		default:
			throw std::runtime_error("unknown opcode");
	}
}

/// Calls the function \a fn for all signals that are being simulated, passing
/// it each signal and that signal's current value. Useful to get a dump of the
/// current simulation state.
void Simulation::eachSignal(ObserverFunc fn) {
	for (auto& is : wrappers) {
		fn(T, is.second->getAssemblySignal(), is.second->getValue());
	}
}

/// Adds an event to the event queue. Useful for debugging and applying external
/// stimuli generated by the user.
void Simulation::addEvent(
	SimulationTime T,
	const AssemblySignal* signal,
	const SimulationValue& value) {

	auto it = wrappers.find(signal);
	if (it == wrappers.end())
		return;

	eventQueue.addEvent(T, it->second.get(), value);
}

/// Advances the simulation one step and calls \a fn for all signals that have
/// changed their value.
void Simulation::step(ObserverFunc fn) {

	// Do nothing if the event queue is empty.
	if (eventQueue.isAtEnd())
		return;

	// Fetch the next time step from the queue and iterate over all events that
	// are listed for that specific point in time.
	T = eventQueue.nextTime();
	std::vector<SimulationDependency*> outdated;
	outdated.reserve(64);
	eventQueue.nextEvents([&](const SimulationEvent& ev){
		auto& sig = *ev.signal;
		if (sig.getValue() == ev.value)
			return;
		sig.setValue(ev.value);
		fn(T, sig.getAssemblySignal(), ev.value);

		// Mark all dependencies of this signal as outdated.
		sig.eachDependency([&](SimulationDependency *dep){
			if (dep->markOutdated())
				outdated.push_back(dep);
		});
	});
	eventQueue.pop();

	// Update all dependencies that were marked outdated.
	for (auto dep : outdated) {
		dep->update(T, eventQueue);
		dep->clearOutdated();
	}
}
